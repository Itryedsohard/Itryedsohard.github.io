<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面向切片编程</title>
    <link href="/2023/05/19/%E9%9D%A2%E5%90%91%E5%88%87%E7%89%87%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/05/19/%E9%9D%A2%E5%90%91%E5%88%87%E7%89%87%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//回调函数是高阶函数的一种</span><br><span class="hljs-comment">//高阶函数 1) 如果函数的参数是一个函数 或者 2) 如果一个函数返了一个函数(返回函数就是高阶函数)</span><br><span class="hljs-comment">//常见的高阶函数应用</span><br><br><span class="hljs-comment">//举例</span><br><span class="hljs-comment">//说话是核心功能</span><br><span class="hljs-comment">//我们希望在核心功能中扩展新的功能且不影响函数原来的功能</span><br><br><br><span class="hljs-comment">//错误示例</span><br><span class="hljs-comment">// function say() &#123;</span><br><span class="hljs-comment">//     // console.log(&#x27;说话前过脑&#x27;);改变了原来的方法，复用性差</span><br><span class="hljs-comment">//     console.log(&#x27;说话&#x27;);</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// say()</span><br><br><br><br><span class="hljs-comment">//AOP面向切片编程，对函数进行扩展（函数劫持）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">who</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(who+<span class="hljs-string">&#x27;说话&#x27;</span>);<br>&#125;<br><br><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">beforSay</span>=<span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-comment">//剩余运算符</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">fn</span>(...args)<br>        <span class="hljs-title function_">this</span>(...args)<span class="hljs-comment">//扩展运算符</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">NewFun</span>=say.<span class="hljs-title function_">beforSay</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">who</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(who+<span class="hljs-string">&#x27;说话前过脑&#x27;</span>);<br>&#125;)<br><span class="hljs-title class_">NewFun</span>(<span class="hljs-string">&#x27;我&#x27;</span>)<br><br><span class="hljs-comment">// 输出结果：</span><br><span class="hljs-comment">// 我说话前过脑</span><br><span class="hljs-comment">// 我说话</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法</title>
    <link href="/2023/05/19/hexo/"/>
    <url>/2023/05/19/hexo/</url>
    
    <content type="html"><![CDATA[<p>写作<br>你可以执行下列命令来创建一篇新文章或者新的页面。</p><p>bash<br>$ hexo new [layout] <title><br>您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。</p><p>布局（Layout）<br>Hexo 有三种默认布局：post、page 和 draft。<br>在创建这三种不同类型的文件时，它们将会被保存到不同的路径；<br>而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。<br>布局    路径<br>post    source/_posts<br>page    source<br>draft    source/_drafts<br>文件名称<br>Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。</p><p>变量    描述<br>:title    标题（小写，空格将会被替换为短杠）<br>:year    建立的年份，比如， 2015<br>:month    建立的月份（有前导零），比如， 04<br>:i_month    建立的月份（无前导零），比如， 4<br>:day    建立的日期（有前导零），比如， 07<br>:i_day    建立的日期（无前导零），比如， 7<br>草稿<br>刚刚提到了 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹，您可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。</p><p>none<br>$ hexo publish [layout] <title><br>草稿默认不会显示在页面中，您可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。</p><p>Front-matter<br>Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。</p><p>配置选项    默认值    描述<br>title    Markdown 的文件标题    文章标题，强烈建议填写此选项<br>date    文件创建时的日期时间    发布时间，强烈建议填写此选项，且最好保证全局唯一<br>author    根 _config.yml 中的 author    文章作者<br>img    featureImages 中的某个值    文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <a href="http://xxx.com/xxx.jpg">http://xxx.com/xxx.jpg</a><br>top    true    推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章<br>hide    false    隐藏文章，如果hide值为true，则文章不会在首页显示<br>cover    false    v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中<br>coverImg    无    v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片<br>password    无    文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项<br>toc    true    是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项<br>mathjax    false    是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行<br>summary    无    文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<br>categories    无    文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类<br>tags    无    文章标签，一篇文章可以多个标签<br>keywords    文章标题    文章关键字，SEO 时需要<br>reprintPolicy    cc_by    文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个<br>tags:</p><p>HTML | CSS | javaScript | ES6 | git | npm | Node.js | webpack | Vue.js | React.js | 算法 | 设计模式 | 面试 | 微前端 | 工具 | 编程题 | nginx<br>categories:</p><p>开发工具</p><p>前端基础</p><p>面试宝典</p><p>前端框架</p><p>前端运维</p><p>工程化</p><p>架构</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法</title>
    <link href="/2023/05/19/%E7%AE%97%E6%B3%95/"/>
    <url>/2023/05/19/%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 回调函数是高阶函数的一种</span><br><span class="hljs-comment">// 高阶函数 1) 如果函数的参数是一个函数 或者 2) 如果一个函数返了一个函数(返回函数就是高阶函数)</span><br><span class="hljs-comment">//常见的高阶函数应用</span><br><br><span class="hljs-comment">//举例</span><br><span class="hljs-comment">//说话是核心功能</span><br><span class="hljs-comment">//我们希望在核心功能中扩展新的功能且不影响函数原来的功能</span><br><br><br><span class="hljs-comment">//错误示例</span><br><span class="hljs-comment">// function say() &#123;</span><br><span class="hljs-comment">//     // console.log(&#x27;说话前过脑&#x27;);改变了原来的方法，复用性差</span><br><span class="hljs-comment">//     console.log(&#x27;说话&#x27;);</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// say()</span><br><br><br><br><span class="hljs-comment">//AOP面向切片编程，对函数进行扩展（函数劫持）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">who</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(who+<span class="hljs-string">&#x27;说话&#x27;</span>);<br>&#125;<br><br><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">beforSay</span>=<span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-comment">//剩余运算符</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">fn</span>(...args)<br>        <span class="hljs-title function_">this</span>(...args)<span class="hljs-comment">//扩展运算符</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">NewFun</span>=say.<span class="hljs-title function_">beforSay</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">who</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(who+<span class="hljs-string">&#x27;说话前过脑&#x27;</span>);<br>&#125;)<br><span class="hljs-title class_">NewFun</span>(<span class="hljs-string">&#x27;我&#x27;</span>)<br><br><span class="hljs-comment">// 输出结果：</span><br><span class="hljs-comment">// 我说话前过脑</span><br><span class="hljs-comment">// 我说话</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
